<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=CP850">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>--
<span class="lineno">    2 </span>-- Projecto CP 2015/16
<span class="lineno">    3 </span>--
<span class="lineno">    4 </span>-- O projecto consiste em desenvolver testes para o módulo Graph.hs
<span class="lineno">    5 </span>-- (para grafos orientados e não pesados).
<span class="lineno">    6 </span>-- Mais concretamente, o projecto consiste em 3 tarefas que são descritas abaixo.
<span class="lineno">    7 </span>-- O prazo para entrega é o dia 3 de Abril. Cada grupo deve enviar apenas
<span class="lineno">    8 </span>-- o módulo de testes (este módulo) por email para calculodeprogramas@gmail.com
<span class="lineno">    9 </span>-- O nome do ficheiro deve identificar os números dos 2 alunos do grupo (numero1_numero2.hs).
<span class="lineno">   10 </span>-- Certifiquem-se que o módulo de testes desenvolvido compila correctamente antes
<span class="lineno">   11 </span>-- de submeter. O módulo Graph.hs não deve ser alterado.
<span class="lineno">   12 </span>-- Os 2 alunos do grupo devem também indentificar-se nos comentários abaixo.
<span class="lineno">   13 </span>--
<span class="lineno">   14 </span>-- Aluno 1
<span class="lineno">   15 </span>-- Número: A75662
<span class="lineno">   16 </span>-- Nome: Fábio Luís Baião da Silva
<span class="lineno">   17 </span>-- Curso: MiEI
<span class="lineno">   18 </span>--
<span class="lineno">   19 </span>-- Aluno 2
<span class="lineno">   20 </span>-- Número: A74601
<span class="lineno">   21 </span>-- Nome: José Miguel Ribeiro da Silva
<span class="lineno">   22 </span>-- Curso: MiEI
<span class="lineno">   23 </span>--
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>module Main where
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>import Graph
<span class="lineno">   28 </span>import Test.HUnit hiding (path)
<span class="lineno">   29 </span>import Test.QuickCheck
<span class="lineno">   30 </span>import Data.Set as Set
<span class="lineno">   31 </span>
<span class="lineno">   32 </span>--
<span class="lineno">   33 </span>-- Teste unitário
<span class="lineno">   34 </span>--
<span class="lineno">   35 </span>
<span class="lineno">   36 </span>e1 :: Edge Int
<span class="lineno">   37 </span><span class="decl"><span class="istickedoff">e1 = Edge { </span>
<span class="lineno">   38 </span><span class="spaces">    </span><span class="istickedoff">source = 1,</span>
<span class="lineno">   39 </span><span class="spaces">    </span><span class="istickedoff">target = 2</span>
<span class="lineno">   40 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   41 </span>
<span class="lineno">   42 </span>g0 :: Graph Int
<span class="lineno">   43 </span><span class="decl"><span class="istickedoff">g0 = Graph {</span>
<span class="lineno">   44 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [],</span>
<span class="lineno">   45 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList []</span>
<span class="lineno">   46 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   47 </span>
<span class="lineno">   48 </span>g1 :: Graph Int
<span class="lineno">   49 </span><span class="decl"><span class="istickedoff">g1 = Graph {</span>
<span class="lineno">   50 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1],</span>
<span class="lineno">   51 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 1]</span>
<span class="lineno">   52 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   53 </span>
<span class="lineno">   54 </span>g2 :: Graph Int
<span class="lineno">   55 </span><span class="decl"><span class="istickedoff">g2 = Graph { </span>
<span class="lineno">   56 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">   57 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 2 3, Edge 3 1]</span>
<span class="lineno">   58 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>g2trans :: Graph Int
<span class="lineno">   61 </span><span class="decl"><span class="istickedoff">g2trans = Graph {</span>
<span class="lineno">   62 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">   63 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 2 1, Edge 3 2, Edge 1 3]</span>
<span class="lineno">   64 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>g2forest :: Graph Int
<span class="lineno">   67 </span><span class="decl"><span class="istickedoff">g2forest = Graph {</span>
<span class="lineno">   68 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">   69 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 2 1, Edge 3 2]</span>
<span class="lineno">   70 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   71 </span>
<span class="lineno">   72 </span>-- Grafo inválido
<span class="lineno">   73 </span>g3 :: Graph Int
<span class="lineno">   74 </span><span class="decl"><span class="istickedoff">g3 = Graph {</span>
<span class="lineno">   75 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">   76 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 2 3, Edge 1 4, Edge 4 2]</span>
<span class="lineno">   77 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>g4 :: Graph Int
<span class="lineno">   80 </span><span class="decl"><span class="istickedoff">g4 = Graph {</span>
<span class="lineno">   81 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">   82 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 1 3]</span>
<span class="lineno">   83 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>g4trans :: Graph Int
<span class="lineno">   86 </span><span class="decl"><span class="istickedoff">g4trans = Graph {</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">   88 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 2 1, Edge 3 1]</span>
<span class="lineno">   89 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>g4forest :: Graph Int
<span class="lineno">   92 </span><span class="decl"><span class="istickedoff">g4forest = Graph {</span>
<span class="lineno">   93 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3], </span>
<span class="lineno">   94 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 2 1, Edge 3 1]</span>
<span class="lineno">   95 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>g5 :: Graph Int
<span class="lineno">   98 </span><span class="decl"><span class="istickedoff">g5 = Graph {</span>
<span class="lineno">   99 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">  100 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 3, Edge 2 3]</span>
<span class="lineno">  101 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>g5trans :: Graph Int
<span class="lineno">  104 </span><span class="decl"><span class="istickedoff">g5trans = Graph {</span>
<span class="lineno">  105 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3],</span>
<span class="lineno">  106 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 3 1, Edge 3 2]</span>
<span class="lineno">  107 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  108 </span>
<span class="lineno">  109 </span>g6 :: Graph Int
<span class="lineno">  110 </span><span class="decl"><span class="istickedoff">g6 = Graph {</span>
<span class="lineno">  111 </span><span class="spaces">  </span><span class="istickedoff">nodes = fromList [1,2,3,4],</span>
<span class="lineno">  112 </span><span class="spaces">  </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 2 3, Edge 1 3, Edge 4 1]</span>
<span class="lineno">  113 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>g2_6 :: Graph Int
<span class="lineno">  116 </span><span class="decl"><span class="istickedoff">g2_6 = Graph {</span>
<span class="lineno">  117 </span><span class="spaces">  </span><span class="istickedoff">nodes = fromList [1,2,3,4],</span>
<span class="lineno">  118 </span><span class="spaces">  </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 2 3, Edge 3 1, Edge 1 3, Edge 4 1]</span>
<span class="lineno">  119 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>g7 :: Graph Int
<span class="lineno">  122 </span><span class="decl"><span class="istickedoff">g7 = Graph {</span>
<span class="lineno">  123 </span><span class="spaces">    </span><span class="istickedoff">nodes = <span class="nottickedoff">fromList [1,2,3,4,5,6,7,8,9]</span>,</span>
<span class="lineno">  124 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 1 3, Edge 1 4, Edge 2 4, </span>
<span class="lineno">  125 </span><span class="spaces">                    </span><span class="istickedoff">Edge 4 5, Edge 4 6, Edge 6 3, Edge 5 7, </span>
<span class="lineno">  126 </span><span class="spaces">                    </span><span class="istickedoff">Edge 7 8, Edge 8 2, Edge 9 3, Edge 9 6, Edge 9 7]</span>
<span class="lineno">  127 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  128 </span>
<span class="lineno">  129 </span>g7forest :: Forest Int
<span class="lineno">  130 </span><span class="decl"><span class="nottickedoff">g7forest = Graph {</span>
<span class="lineno">  131 </span><span class="spaces">    </span><span class="nottickedoff">nodes = fromList [1,2,3,4,5,6,7,8],</span>
<span class="lineno">  132 </span><span class="spaces">    </span><span class="nottickedoff">edges = fromList [Edge 1 2, Edge 1 3, Edge 1 4, Edge 2 4, </span>
<span class="lineno">  133 </span><span class="spaces">                    </span><span class="nottickedoff">Edge 4 5, Edge 4 6, Edge 5 7, Edge 7 8]</span>
<span class="lineno">  134 </span><span class="spaces"></span><span class="nottickedoff">}</span></span>
<span class="lineno">  135 </span>
<span class="lineno">  136 </span>g8 :: DAG Int
<span class="lineno">  137 </span><span class="decl"><span class="istickedoff">g8 = Graph {</span>
<span class="lineno">  138 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3,4,5,6,7],</span>
<span class="lineno">  139 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 2 5, Edge 5 3, Edge 3 7, Edge 3 6, Edge 7 4]</span>
<span class="lineno">  140 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>g9 :: Graph Int
<span class="lineno">  143 </span><span class="decl"><span class="istickedoff">g9 = Graph {</span>
<span class="lineno">  144 </span><span class="spaces">    </span><span class="istickedoff">nodes = fromList [1,2,3,4,5,6],</span>
<span class="lineno">  145 </span><span class="spaces">    </span><span class="istickedoff">edges = fromList [Edge 1 2, Edge 2 2, Edge 2 4, Edge 2 5, </span>
<span class="lineno">  146 </span><span class="spaces">                    </span><span class="istickedoff">Edge 4 1, Edge 4 5, Edge 5 4, Edge 6 3]</span>
<span class="lineno">  147 </span><span class="spaces"></span><span class="istickedoff">}</span></span>
<span class="lineno">  148 </span>
<span class="lineno">  149 </span>-- Um exemplo de um teste unitário.
<span class="lineno">  150 </span>test_adj :: Test
<span class="lineno">  151 </span><span class="decl"><span class="istickedoff">test_adj = adj g1 1 ~?= fromList [Edge 1 1]</span></span>
<span class="lineno">  152 </span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>--
<span class="lineno">  155 </span>-- Tarefa 1
<span class="lineno">  156 </span>--
<span class="lineno">  157 </span>-- Defina testes unitários para todas as funções do módulo Graph,
<span class="lineno">  158 </span>-- tentando obter o máximo de cobertura de expressões, condições, etc.
<span class="lineno">  159 </span>--
<span class="lineno">  160 </span>
<span class="lineno">  161 </span>test_swap :: Test
<span class="lineno">  162 </span><span class="decl"><span class="istickedoff">test_swap = swap e1 ~?= Edge 2 1</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>test_empty :: Test
<span class="lineno">  165 </span><span class="decl"><span class="istickedoff">test_empty = Graph.empty ~?= g0</span></span>
<span class="lineno">  166 </span>
<span class="lineno">  167 </span>testL_isEmpty :: Test
<span class="lineno">  168 </span><span class="decl"><span class="istickedoff">testL_isEmpty = TestList  [</span>
<span class="lineno">  169 </span><span class="spaces">    </span><span class="istickedoff">isEmpty g0 ~?= True,</span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">isEmpty g1 ~?= False</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>testL_isValid :: Test
<span class="lineno">  174 </span><span class="decl"><span class="istickedoff">testL_isValid = TestList [</span>
<span class="lineno">  175 </span><span class="spaces">    </span><span class="istickedoff">isValid g9 ~?= True,</span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="istickedoff">isValid g3 ~?= False</span>
<span class="lineno">  177 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  178 </span>
<span class="lineno">  179 </span><span class="decl"><span class="istickedoff">testL_isDAG = TestList [</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">isDAG g9 ~?= False,</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">isDAG g8 ~?= True</span>
<span class="lineno">  182 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  183 </span>
<span class="lineno">  184 </span><span class="decl"><span class="istickedoff">testL_isForest = TestList [</span>
<span class="lineno">  185 </span><span class="spaces">    </span><span class="istickedoff">isForest g0 ~?= True,</span>
<span class="lineno">  186 </span><span class="spaces">    </span><span class="istickedoff">isForest g4 ~?= False,</span>
<span class="lineno">  187 </span><span class="spaces">    </span><span class="istickedoff">isForest g5 ~?= True</span>
<span class="lineno">  188 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  189 </span>
<span class="lineno">  190 </span><span class="decl"><span class="istickedoff">testL_isSubgraphOf = TestList [</span>
<span class="lineno">  191 </span><span class="spaces">    </span><span class="istickedoff">isSubgraphOf g0 g6 ~?= True,</span>
<span class="lineno">  192 </span><span class="spaces">    </span><span class="istickedoff">isSubgraphOf g5 g6 ~?= True,</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="istickedoff">isSubgraphOf g6 g5 ~?= False</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  195 </span>
<span class="lineno">  196 </span><span class="decl"><span class="istickedoff">testL_adj = TestList [</span>
<span class="lineno">  197 </span><span class="spaces">    </span><span class="istickedoff">test_adj,</span>
<span class="lineno">  198 </span><span class="spaces">    </span><span class="istickedoff">adj g6 2 ~?= fromList [Edge 2 3],</span>
<span class="lineno">  199 </span><span class="spaces">    </span><span class="istickedoff">adj g6 1 ~?= fromList [Edge 1 3, Edge 1 2],</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">adj g6 3 ~?= fromList []</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span><span class="decl"><span class="istickedoff">testL_transpose = TestList [</span>
<span class="lineno">  204 </span><span class="spaces">    </span><span class="istickedoff">transpose g0 ~?= g0,</span>
<span class="lineno">  205 </span><span class="spaces">    </span><span class="istickedoff">transpose g2 ~?= g2trans,</span>
<span class="lineno">  206 </span><span class="spaces">    </span><span class="istickedoff">transpose g4 ~?= g4trans,</span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">transpose g5 ~?= g5trans</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span><span class="decl"><span class="istickedoff">testL_union = TestList [</span>
<span class="lineno">  211 </span><span class="spaces">    </span><span class="istickedoff">Graph.union g6 g0 ~?= g6,</span>
<span class="lineno">  212 </span><span class="spaces">    </span><span class="istickedoff">Graph.union g2 g6 ~?= g2_6,</span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">Graph.union g6 g2 ~?= g2_6</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  215 </span>
<span class="lineno">  216 </span><span class="decl"><span class="istickedoff">testL_bft = TestList [</span>
<span class="lineno">  217 </span><span class="spaces">    </span><span class="istickedoff">bft <span class="nottickedoff">g0</span> (fromList []) ~?= g0,</span>
<span class="lineno">  218 </span><span class="spaces">    </span><span class="istickedoff">bft g2 (fromList [1]) ~?= g2forest,</span>
<span class="lineno">  219 </span><span class="spaces">    </span><span class="istickedoff">bft g4 (fromList [1]) ~?= g4forest</span>
<span class="lineno">  220 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  221 </span>
<span class="lineno">  222 </span><span class="decl"><span class="istickedoff">testL_reachable = TestList [</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">reachable g6 1 ~?= fromList [1,2,3],</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">reachable g6 3 ~?= fromList [3],</span>
<span class="lineno">  225 </span><span class="spaces">    </span><span class="istickedoff">reachable g5 1 ~?= fromList [1,3]</span>
<span class="lineno">  226 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  227 </span>
<span class="lineno">  228 </span><span class="decl"><span class="istickedoff">testL_isPathOf = TestList [</span>
<span class="lineno">  229 </span><span class="spaces">    </span><span class="istickedoff">isPathOf [] <span class="nottickedoff">g0</span> ~?= True,</span>
<span class="lineno">  230 </span><span class="spaces">    </span><span class="istickedoff">isPathOf [Edge 4 1, Edge 1 2, Edge 2 3] g6 ~?= True,</span>
<span class="lineno">  231 </span><span class="spaces">    </span><span class="istickedoff">isPathOf [Edge 4 1, Edge 1 3, Edge 3 <span class="nottickedoff">2</span>] g6 ~?= False</span>
<span class="lineno">  232 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  233 </span>
<span class="lineno">  234 </span><span class="decl"><span class="istickedoff">testL_path = TestList [</span>
<span class="lineno">  235 </span><span class="spaces">    </span><span class="istickedoff">path g6 4 3 ~?= Just [Edge 4 1, Edge 1 3],</span>
<span class="lineno">  236 </span><span class="spaces">    </span><span class="istickedoff">path g5 1 2 ~?= Nothing,</span>
<span class="lineno">  237 </span><span class="spaces">    </span><span class="istickedoff">path g6 2 1 ~?= Nothing,</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="istickedoff">path g7 1 7 ~?= Just [Edge 1 4, Edge 4 5, Edge 5 7]</span>
<span class="lineno">  239 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  240 </span>
<span class="lineno">  241 </span><span class="decl"><span class="istickedoff">testL_topo = TestList [</span>
<span class="lineno">  242 </span><span class="spaces">    </span><span class="istickedoff">topo g5 ~?= [fromList [1,2], fromList [3]],</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">topo g8 ~?= [fromList [1], fromList [2], fromList [5], </span>
<span class="lineno">  244 </span><span class="spaces">                </span><span class="istickedoff">fromList [3], fromList [7,6], fromList [4]]</span>
<span class="lineno">  245 </span><span class="spaces">    </span><span class="istickedoff">]</span></span>
<span class="lineno">  246 </span>
<span class="lineno">  247 </span><span class="decl"><span class="istickedoff">main = runTestTT $ TestList [</span>
<span class="lineno">  248 </span><span class="spaces">                            </span><span class="istickedoff">test_swap,</span>
<span class="lineno">  249 </span><span class="spaces">                            </span><span class="istickedoff">test_empty,</span>
<span class="lineno">  250 </span><span class="spaces">                            </span><span class="istickedoff">testL_isEmpty,</span>
<span class="lineno">  251 </span><span class="spaces">                            </span><span class="istickedoff">testL_isValid,</span>
<span class="lineno">  252 </span><span class="spaces">                            </span><span class="istickedoff">testL_isDAG,</span>
<span class="lineno">  253 </span><span class="spaces">                            </span><span class="istickedoff">testL_isForest,</span>
<span class="lineno">  254 </span><span class="spaces">                            </span><span class="istickedoff">testL_isSubgraphOf,</span>
<span class="lineno">  255 </span><span class="spaces">                            </span><span class="istickedoff">testL_adj,</span>
<span class="lineno">  256 </span><span class="spaces">                            </span><span class="istickedoff">testL_transpose,</span>
<span class="lineno">  257 </span><span class="spaces">                            </span><span class="istickedoff">testL_union,</span>
<span class="lineno">  258 </span><span class="spaces">                            </span><span class="istickedoff">testL_bft,</span>
<span class="lineno">  259 </span><span class="spaces">                            </span><span class="istickedoff">testL_reachable,</span>
<span class="lineno">  260 </span><span class="spaces">                            </span><span class="istickedoff">testL_isPathOf,</span>
<span class="lineno">  261 </span><span class="spaces">                            </span><span class="istickedoff">testL_path,</span>
<span class="lineno">  262 </span><span class="spaces">                            </span><span class="istickedoff">testL_topo</span>
<span class="lineno">  263 </span><span class="spaces">                            </span><span class="istickedoff">]</span></span>
<span class="lineno">  264 </span>
<span class="lineno">  265 </span>--
<span class="lineno">  266 </span>-- Teste aleatório
<span class="lineno">  267 </span>--
<span class="lineno">  268 </span>
<span class="lineno">  269 </span>--
<span class="lineno">  270 </span>-- Tarefa 2
<span class="lineno">  271 </span>--
<span class="lineno">  272 </span>-- A instância de Arbitrary para grafos definida abaixo gera grafos
<span class="lineno">  273 </span>-- com muito poucas arestas, como se pode constatar testando a
<span class="lineno">  274 </span>-- propriedade prop_valid.
<span class="lineno">  275 </span>-- Defina uma instância de Arbitrary menos enviesada.
<span class="lineno">  276 </span>-- Este problema ainda é mais grave nos geradores dag e forest que
<span class="lineno">  277 </span>-- têm como objectivo gerar, respectivamente, grafos que satisfazem
<span class="lineno">  278 </span>-- os predicados isDag e isForest. Estes geradores serão necessários
<span class="lineno">  279 </span>-- para testar propriedades sobre estas classes de grafos.
<span class="lineno">  280 </span>-- Melhore a implementação destes geradores por forma a serem menos enviesados.
<span class="lineno">  281 </span>--
<span class="lineno">  282 </span>
<span class="lineno">  283 </span>-- Instância de Arbitrary para arestas
<span class="lineno">  284 </span>instance Arbitrary v =&gt; Arbitrary (Edge v) where
<span class="lineno">  285 </span>    <span class="decl"><span class="nottickedoff">arbitrary = do s &lt;- arbitrary</span>
<span class="lineno">  286 </span><span class="spaces">                   </span><span class="nottickedoff">t &lt;- arbitrary</span>
<span class="lineno">  287 </span><span class="spaces">                   </span><span class="nottickedoff">return $ Edge {source = s, target = t}</span></span>
<span class="lineno">  288 </span>
<span class="lineno">  289 </span>instance (Ord v, Arbitrary v) =&gt; Arbitrary (Graph v) where
<span class="lineno">  290 </span>    <span class="decl"><span class="nottickedoff">arbitrary = do ns &lt;- arbitrary</span>
<span class="lineno">  291 </span><span class="spaces">                   </span><span class="nottickedoff">es &lt;- creatEdges ns</span>
<span class="lineno">  292 </span><span class="spaces">                   </span><span class="nottickedoff">return $ Graph {nodes = fromList ns, edges = fromList es}</span>
<span class="lineno">  293 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  294 </span><span class="spaces">        </span><span class="nottickedoff">where creatEdges ns = frequency [(1, empty), (length (ns) * 3, list ns)]</span>
<span class="lineno">  295 </span><span class="spaces">              </span><span class="nottickedoff">empty = return []</span>
<span class="lineno">  296 </span><span class="spaces">              </span><span class="nottickedoff">list ns = do a &lt;- elements (ns)</span>
<span class="lineno">  297 </span><span class="spaces">                           </span><span class="nottickedoff">b &lt;- elements (ns)</span>
<span class="lineno">  298 </span><span class="spaces">                           </span><span class="nottickedoff">l &lt;- creatEdges ns</span>
<span class="lineno">  299 </span><span class="spaces">                           </span><span class="nottickedoff">return $ Edge {source = a, target = b} : l</span></span>
<span class="lineno">  300 </span> 
<span class="lineno">  301 </span>prop_valid :: Graph Int -&gt; Property
<span class="lineno">  302 </span><span class="decl"><span class="nottickedoff">prop_valid g = collect (length (edges g)) $ isValid g</span></span>
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>-- Gerador de DAGs
<span class="lineno">  305 </span>dag :: (Ord v, Arbitrary v) =&gt; Gen (DAG v)
<span class="lineno">  306 </span><span class="decl"><span class="nottickedoff">dag = do g &lt;- arbitrary</span>
<span class="lineno">  307 </span><span class="spaces">         </span><span class="nottickedoff">return Graph {nodes = nodes g, edges = fromList $ edgesDAG (elems (edges g))}</span>
<span class="lineno">  308 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  309 </span><span class="spaces">    </span><span class="nottickedoff">where edgesDAG [] = []</span>
<span class="lineno">  310 </span><span class="spaces">          </span><span class="nottickedoff">edgesDAG (h@(Edge sr tr):t) = if (sr &gt;= tr)</span>
<span class="lineno">  311 </span><span class="spaces">                                        </span><span class="nottickedoff">then edgesDAG (t)</span>
<span class="lineno">  312 </span><span class="spaces">                                        </span><span class="nottickedoff">else h : edgesDAG (t)</span></span>
<span class="lineno">  313 </span>
<span class="lineno">  314 </span>prop_dag :: Property
<span class="lineno">  315 </span><span class="decl"><span class="nottickedoff">prop_dag = forAll (dag :: Gen (DAG Int)) $ \g -&gt; collect (length (edges g)) $ isDAG g</span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>-- Gerador de florestas
<span class="lineno">  318 </span>forest :: (Ord v, Arbitrary v) =&gt; Gen (Forest v)
<span class="lineno">  319 </span><span class="decl"><span class="nottickedoff">forest = do g &lt;- dag</span>
<span class="lineno">  320 </span><span class="spaces">            </span><span class="nottickedoff">return Graph {nodes = nodes g, edges = fromList $ aux (elems (edges g))}</span>
<span class="lineno">  321 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="nottickedoff">where aux [] = []</span>
<span class="lineno">  323 </span><span class="spaces">          </span><span class="nottickedoff">aux (h@(Edge sr tr):t) = h : aux (aux2 sr t)</span>
<span class="lineno">  324 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  325 </span><span class="spaces">          </span><span class="nottickedoff">aux2 _ [] = []</span>
<span class="lineno">  326 </span><span class="spaces">          </span><span class="nottickedoff">aux2 sr (h@(Edge o d):t) = if (sr == o)</span>
<span class="lineno">  327 </span><span class="spaces">                                   </span><span class="nottickedoff">then aux2 sr t</span>
<span class="lineno">  328 </span><span class="spaces">                                   </span><span class="nottickedoff">else h : t</span></span>
<span class="lineno">  329 </span>
<span class="lineno">  330 </span>prop_forest :: Property
<span class="lineno">  331 </span><span class="decl"><span class="nottickedoff">prop_forest = forAll (forest :: Gen (Forest Int)) $ \g -&gt; collect (length (edges g)) $ isForest g</span></span>
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>--
<span class="lineno">  334 </span>-- Tarefa 3
<span class="lineno">  335 </span>--
<span class="lineno">  336 </span>-- Defina propriedades QuickCheck para testar todas as funções
<span class="lineno">  337 </span>-- do módulo Graph.
<span class="lineno">  338 </span>--
<span class="lineno">  339 </span>
<span class="lineno">  340 </span>-- Exemplo de uma propriedade QuickCheck para testar a função adj          
<span class="lineno">  341 </span>prop_adj :: Graph Int -&gt; Property
<span class="lineno">  342 </span><span class="decl"><span class="nottickedoff">prop_adj g = forAll (elements $ elems $ nodes g) $ \v -&gt; adj g v `isSubsetOf` edges g</span></span>
<span class="lineno">  343 </span>
<span class="lineno">  344 </span>prop_swap :: Edge Int -&gt; Property
<span class="lineno">  345 </span><span class="decl"><span class="nottickedoff">prop_swap (Edge s t) = property $ swap (Edge s t) == (Edge t s)</span></span>
<span class="lineno">  346 </span>
<span class="lineno">  347 </span>prop_empty :: Property
<span class="lineno">  348 </span><span class="decl"><span class="nottickedoff">prop_empty = property $ Graph.empty == g0</span></span>
<span class="lineno">  349 </span>
<span class="lineno">  350 </span>prop_isEmpty :: Graph Int -&gt; Property
<span class="lineno">  351 </span><span class="decl"><span class="nottickedoff">prop_isEmpty g = property $ if (isEmpty g)</span>
<span class="lineno">  352 </span><span class="spaces">                            </span><span class="nottickedoff">then length (nodes g) == 0</span>
<span class="lineno">  353 </span><span class="spaces">                            </span><span class="nottickedoff">else length (nodes g) /= 0</span></span>
<span class="lineno">  354 </span>
<span class="lineno">  355 </span>prop_isValid :: Graph Int -&gt; Property
<span class="lineno">  356 </span><span class="decl"><span class="nottickedoff">prop_isValid g = property $ isValid g == edgesValid (nodes g) (elems (edges g))</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="nottickedoff">where edgesValid _ [] = True</span>
<span class="lineno">  358 </span><span class="spaces">          </span><span class="nottickedoff">edgesValid n ((Edge sr tr):t) | member sr n &amp;&amp; member tr n = edgesValid n t</span>
<span class="lineno">  359 </span><span class="spaces">                                        </span><span class="nottickedoff">| otherwise = False</span></span>
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>prop_isDAG :: Graph Int -&gt; Property
<span class="lineno">  362 </span><span class="decl"><span class="nottickedoff">prop_isDAG g = let b = srcANDtrg (elems (edges g))</span>
<span class="lineno">  363 </span><span class="spaces">                </span><span class="nottickedoff">in if (b)</span>
<span class="lineno">  364 </span><span class="spaces">                   </span><span class="nottickedoff">then label &quot;Unknown&quot; True</span>
<span class="lineno">  365 </span><span class="spaces">                   </span><span class="nottickedoff">else property $ b == isDAG g</span>
<span class="lineno">  366 </span><span class="spaces"></span><span class="nottickedoff"></span>
<span class="lineno">  367 </span><span class="spaces">    </span><span class="nottickedoff">where srcANDtrg [] = True</span>
<span class="lineno">  368 </span><span class="spaces">          </span><span class="nottickedoff">srcANDtrg ((Edge sr tr):t) = if (sr == tr)</span>
<span class="lineno">  369 </span><span class="spaces">                                       </span><span class="nottickedoff">then False</span>
<span class="lineno">  370 </span><span class="spaces">                                       </span><span class="nottickedoff">else srcANDtrg t</span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>prop_isForest :: Property
<span class="lineno">  373 </span><span class="decl"><span class="nottickedoff">prop_isForest = forAll (dag :: Gen (DAG Int)) $ aux_isForest</span></span>
<span class="lineno">  374 </span>
<span class="lineno">  375 </span>aux_isForest :: DAG Int -&gt; Property
<span class="lineno">  376 </span><span class="decl"><span class="nottickedoff">aux_isForest d = property $ isForest (d) == edgesForest (elems (edges d))</span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="nottickedoff">where edgesForest [] = True</span>
<span class="lineno">  378 </span><span class="spaces">          </span><span class="nottickedoff">edgesForest ((Edge sr _):t) | exists sr t = False</span>
<span class="lineno">  379 </span><span class="spaces">                                      </span><span class="nottickedoff">| otherwise = edgesForest t</span>
<span class="lineno">  380 </span><span class="spaces">          </span><span class="nottickedoff">exists _ [] = False</span>
<span class="lineno">  381 </span><span class="spaces">          </span><span class="nottickedoff">exists s ((Edge sr _):t) | s == sr = True</span>
<span class="lineno">  382 </span><span class="spaces">                                   </span><span class="nottickedoff">| otherwise = exists s t</span></span>
<span class="lineno">  383 </span>
<span class="lineno">  384 </span>prop_isSubgraphOf :: Graph Int -&gt; Property
<span class="lineno">  385 </span><span class="decl"><span class="nottickedoff">prop_isSubgraphOf g = property $ isSubgraphOf g g == True</span></span> 
<span class="lineno">  386 </span>
<span class="lineno">  387 </span>prop_isSubgraphOf1 :: Graph Int -&gt; Property
<span class="lineno">  388 </span><span class="decl"><span class="nottickedoff">prop_isSubgraphOf1 g = property $ isSubgraphOf Graph {nodes = (nodes g), edges = (aux)} g == True</span>
<span class="lineno">  389 </span><span class="spaces">    </span><span class="nottickedoff">where aux = deleteMax $ deleteMin (edges g)</span></span>
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>prop_adj1 :: Graph Int -&gt; Property
<span class="lineno">  392 </span><span class="decl"><span class="nottickedoff">prop_adj1 g = (length (nodes g) /= 0)</span>
<span class="lineno">  393 </span><span class="spaces">              </span><span class="nottickedoff">==&gt; forAll (elements $ elems $ nodes g) $ aux_adj1 g</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>aux_adj1 :: Graph Int -&gt; Int -&gt; Property
<span class="lineno">  396 </span><span class="decl"><span class="nottickedoff">aux_adj1 g v = let l = adj g v</span>
<span class="lineno">  397 </span><span class="spaces">                </span><span class="nottickedoff">in property $ allSources (elems l)</span>
<span class="lineno">  398 </span><span class="spaces">    </span><span class="nottickedoff">where allSources [] = True</span>
<span class="lineno">  399 </span><span class="spaces">          </span><span class="nottickedoff">allSources ((Edge sr _):t) = if (sr == v)</span>
<span class="lineno">  400 </span><span class="spaces">                                       </span><span class="nottickedoff">then allSources t</span>
<span class="lineno">  401 </span><span class="spaces">                                       </span><span class="nottickedoff">else False</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>prop_transpose :: Graph Int -&gt; Property
<span class="lineno">  404 </span><span class="decl"><span class="nottickedoff">prop_transpose g = property $ length (edges g) == length (edges (transpose g))</span></span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>prop_transpose1 :: Graph Int -&gt; Property
<span class="lineno">  407 </span><span class="decl"><span class="nottickedoff">prop_transpose1 g = property $ transpose (transpose (g)) == g</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>{- Compara cada um dos edges do grafo original com os obtidos
<span class="lineno">  410 </span>   depois de aplicar a função transpose, verificando se existe 
<span class="lineno">  411 </span>   o inverso para cada um -}
<span class="lineno">  412 </span>prop_transpose2 :: Graph Int -&gt; Property
<span class="lineno">  413 </span><span class="decl"><span class="nottickedoff">prop_transpose2 g = property $ check_trans (elems $ edges g) (edges $ transpose g) </span>
<span class="lineno">  414 </span><span class="spaces">    </span><span class="nottickedoff">where check_trans [] _ = True</span>
<span class="lineno">  415 </span><span class="spaces">          </span><span class="nottickedoff">check_trans ((Edge k w):t) lt = (Edge w k) `member` lt &amp;&amp; check_trans t lt</span></span> 
<span class="lineno">  416 </span>
<span class="lineno">  417 </span>prop_union :: Graph Int -&gt; Property
<span class="lineno">  418 </span><span class="decl"><span class="nottickedoff">prop_union g = property $ Graph.union g g == g</span></span>
<span class="lineno">  419 </span>
<span class="lineno">  420 </span>prop_union1 :: Graph Int -&gt; Graph Int -&gt; Property
<span class="lineno">  421 </span><span class="decl"><span class="nottickedoff">prop_union1 g1 g2 = property $ length (nodes (Graph.union g1 g2)) &lt;= length (nodes g1) + length (nodes g2)</span></span>
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>prop_union2 :: Graph Int -&gt; Graph Int -&gt; Property
<span class="lineno">  424 </span><span class="decl"><span class="nottickedoff">prop_union2 g1 g2 = property $ let u = Graph.union g1 g2</span>
<span class="lineno">  425 </span><span class="spaces">                                </span><span class="nottickedoff">in (nodes g1) `isSubsetOf` (nodes u) &amp;&amp; (nodes g2) `isSubsetOf` (nodes u)</span>
<span class="lineno">  426 </span><span class="spaces">                                    </span><span class="nottickedoff">&amp;&amp; (edges g1) `isSubsetOf` (edges u) &amp;&amp; (edges g2) `isSubsetOf` (edges u)</span></span>
<span class="lineno">  427 </span>
<span class="lineno">  428 </span>prop_bft :: Graph Int -&gt; Property
<span class="lineno">  429 </span><span class="decl"><span class="nottickedoff">prop_bft g = ((length $ nodes g) /= 0) ==&gt; forAll (elements $ elems $ nodes g) $ aux_bft g</span></span> 
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>aux_bft :: Graph Int -&gt; Int -&gt; Property
<span class="lineno">  432 </span><span class="decl"><span class="nottickedoff">aux_bft g e = let f = bft g (singleton e)</span>
<span class="lineno">  433 </span><span class="spaces">              </span><span class="nottickedoff">in property $ (singleton e) `isSubsetOf` (nodes f)</span></span>
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>{- Verifica aux_reachable0 e aux_reachable1-}
<span class="lineno">  436 </span>prop_reachable :: Graph Int -&gt; Property
<span class="lineno">  437 </span><span class="decl"><span class="nottickedoff">prop_reachable g = (length (nodes g) /= 0) </span>
<span class="lineno">  438 </span><span class="spaces">                   </span><span class="nottickedoff">==&gt; (forAll (elements $ elems $ nodes g) $ aux_reachable0 g) .&amp;&amp;. </span>
<span class="lineno">  439 </span><span class="spaces">                       </span><span class="nottickedoff">(forAll (elements $ elems $ nodes g) $ aux_reachable1 g)</span></span>
<span class="lineno">  440 </span>
<span class="lineno">  441 </span>{- Verifica se todos os Nodos devolvidos pela função 
<span class="lineno">  442 </span>   reachable fazem parte do grafo -}
<span class="lineno">  443 </span>aux_reachable0 :: Graph Int -&gt; Int -&gt; Property
<span class="lineno">  444 </span><span class="decl"><span class="nottickedoff">aux_reachable0 g el = let vs = reachable g el</span>
<span class="lineno">  445 </span><span class="spaces">                      </span><span class="nottickedoff">in  property $ aux (elems vs)</span>
<span class="lineno">  446 </span><span class="spaces">    </span><span class="nottickedoff">where aux [] = True</span>
<span class="lineno">  447 </span><span class="spaces">          </span><span class="nottickedoff">aux (h:t) = (h `member` (nodes g)) &amp;&amp; aux t</span></span>
<span class="lineno">  448 </span>
<span class="lineno">  449 </span>{- Verifica se todos os Nodos devolvidos pela função
<span class="lineno">  450 </span>   reachable são target em algum dos edges do grafo -}
<span class="lineno">  451 </span>aux_reachable1 :: Graph Int -&gt; Int -&gt; Property
<span class="lineno">  452 </span><span class="decl"><span class="nottickedoff">aux_reachable1 g el = let vs = reachable g el</span>
<span class="lineno">  453 </span><span class="spaces">                      </span><span class="nottickedoff">in property $ aux (elems vs)</span>
<span class="lineno">  454 </span><span class="spaces">    </span><span class="nottickedoff">where aux [] = True</span>
<span class="lineno">  455 </span><span class="spaces">          </span><span class="nottickedoff">aux (h:t) = isTarget h (elems $ edges g) &amp;&amp; aux t</span>
<span class="lineno">  456 </span><span class="spaces">          </span><span class="nottickedoff">isTarget x [] = x == el</span>
<span class="lineno">  457 </span><span class="spaces">          </span><span class="nottickedoff">isTarget x ((Edge s d):t) = (x == el) || (x == d) || isTarget x t</span></span> 
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>prop_isPathOf :: Graph Int -&gt; Property
<span class="lineno">  460 </span><span class="decl"><span class="nottickedoff">prop_isPathOf g = (length (edges g) /= 0)</span>
<span class="lineno">  461 </span><span class="spaces">                  </span><span class="nottickedoff">==&gt; forAll (elements $ elems $ edges g) $ \e@(Edge s t) -&gt; isPathOf [e] g</span></span>
<span class="lineno">  462 </span>
<span class="lineno">  463 </span>{- Depois de obter um edge aleatorio do grafo, verifica se aplicando
<span class="lineno">  464 </span>   a função path ao source e target o resultado é diferente de Nothing -} 
<span class="lineno">  465 </span>prop_path :: Graph Int -&gt; Property
<span class="lineno">  466 </span><span class="decl"><span class="nottickedoff">prop_path g = (length (edges g) /= 0) </span>
<span class="lineno">  467 </span><span class="spaces">              </span><span class="nottickedoff">==&gt; forAll (elements $ elems $ edges g) $ \(Edge x y) -&gt; path g x y /= Nothing</span></span>  
<span class="lineno">  468 </span>
<span class="lineno">  469 </span>prop_topo :: Property
<span class="lineno">  470 </span><span class="decl"><span class="nottickedoff">prop_topo = forAll (dag :: Gen (DAG Int)) $ \d -&gt; (length (topo d) &lt;= length (nodes d))</span></span>

</pre>
</body>
</html>
